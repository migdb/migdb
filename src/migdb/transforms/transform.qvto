/*
 * The MIT License
 * 
 * Copyright (c) 2010-2011 MigDB team [https://rabbit.felk.cvut.cz/trac/migdb]
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 * 
 */
 
modeltype APP uses 'mm-app';
modeltype RDB uses 'mm-db';


transformation APP_To_Rdb(in appModel : APP, out rdb : RDB, out app : APP );

//vstupni bod transformace, najde vsechny RootObjecty, pretypuje na ModelRoot a mapuje pres toRdbRoot
main() {
	log("zacatek transformace");
	//zakomentovanim nasledujiciho radku se neprovede mapovani operaci
	appModel.rootObjects()[APP::reduced::ModelRoot]->toOperated();
	
	//zakomentovani nasledujiciho radku se neprovede mapovani appMoodelu na RDB model
	appModel.rootObjects()[APP::reduced::ModelRoot]->toRdbRoot();
	log("konec transformace");
}

mapping APP::reduced::ModelRoot::toRdbRoot() : RDB::rdb::ModelRoot{
	log("toRdbRoot sekce");
	self.modelGenerations->forEach(generation){
		result.DBgenerations += generation.xmap toDBmodel();
	};
}

// namapuje ModelGeneration na DBgeneration, ktera je prazdna, pokud ma atribut 
// missing nastaven na true, jinak obsahuje schema vyplnene tabulkami namapovanych trid
mapping APP::reduced::ModelGeneration::toDBmodel() : RDB::rdb::Database {
	log("toDBmodel sekce");
	if(self.isMissing = false) then {
		schemas += self.xmap toSchema();
	}endif;
}

mapping APP::reduced::ModelGeneration::toSchema() : RDB::rdb::Schema {
	log("toSchema sekce");		
	
	
	self.classes->forEach(clss | clss.isGeneralClassSerializable() = true and clss.hasSerializableAncestor() = false ){
		result.tables+=clss.xmap toSerializableRootTable();
	};
	
	var maximalDepth : Integer := 0;
	var tempDepth : Integer := 0;
	
	
	self.classes->forEach(clss | clss.hasSingleTableInheritanceType() = true  and clss.hasSerializableAncestor() = true){
		//log(clss.name+" "+ clss.inheritanceType.repr());
		clss.xmap toSingleTable();
	};
	
	self.classes->forEach(clss | clss.hasImplicitInheritanceType() or clss.hasJoinedInheritanceType() ){
		tempDepth := clss.getClassDepth();
		if( tempDepth > maximalDepth ) then {
			maximalDepth := tempDepth;
		}endif;
	};
	
	var i : Integer := 0;
	while( i <= maximalDepth){
		self.classes ->forEach(clss | clss.getClassDepth() = i and (clss.hasJoinedInheritanceType() or clss.hasImplicitInheritanceType())){
			tables+= clss.xmap toJoinedTable();
		};
		i := i+1;
	};
	
	self.classes->forEach(clss | clss.hasTablePerClassInheritanceType() and clss.hasSerializableAncestor() = true){
		tables+=clss.xmap toTablePerClass();
	};
	
	/*end{
	var cls : RDB::rdb::Table := self.classes->selectOne(clss | clss.name = "parent")->resolveone(RDB::rdb::Table);
		log(cls.name);
	}*/	
	
}

//tohle je jeste furt blbe
mapping APP::reduced::Class::toJoinedTable():RDB::rdb::Table 
when{ ( self.hasJoinedInheritanceType() or self.hasImplicitInheritanceType() ) and 
		self.isGeneralClassSerializable() and self.parent <> null }
{
	init{
		var precedessor:RDB::rdb::Table;
		
		var temp: APP::reduced::Class = self.parent;
		//najdi serializovaneho predka
		while(temp.isTransient=true){
		 	temp := temp.parent;
		 };
		 	 
		 precedessor := temp.resolveone(RDB::rdb::Table);
	}
	population{
		log("toJoined Sekce "+self.name);
		var FK:RDB::rdb::ForeignKey = object RDB::rdb::ForeignKey{
			name := "FK " + precedessor.name;	
			targetTable := precedessor;
		};
		
		result.constraints+=FK;
		
		var PKcol:RDB::rdb::TableColumn:= object RDB::rdb::TableColumn{
			name:= self.name + " id";
		};
		
		result.ownedColumns+= PKcol;
		
		var pk : RDB::rdb::PrimaryKey := object RDB::rdb::PrimaryKey{
			name:= "pk "+ self.name;
			underlyingIndex := object RDB::rdb::Index{
				columns+=PKcol;
			}
		};
		
		result.constraints+= pk;
		
		FK.constrainedColumn := PKcol;
		result.name := self.name;  		
	}
}

mapping APP::reduced::Class::toTablePerClass():RDB::rdb::Table
when { self.hasTablePerClassInheritanceType() and self.isGeneralClassSerializable() and self.hasSerializableAncestor()}	
{
	log("toTablePerClass sekce " + self.name);
	name := self.name;
	
	var temp : APP::reduced::Class := self;
	var propSet: OrderedSet(APP::reduced::Property);
	
	while(temp <> null){
		temp->properties->forEach(prop){
			propSet+=prop;
		};
		temp := temp.parent;
	};
	
	propSet->xmap toColumns(result);
}

//u diskriminacniho sloupce neni doresen typ
mapping APP::reduced::Class::toSingleTable()
when { self.hasSingleTableInheritanceType() = true and self.isGeneralClassSerializable() and self.hasSerializableAncestor()}
{	
		var temp:APP::reduced::Class := self.getSerializableRoot();
		
		log("toSingleTable sekce "+self.name);
		var rootTable:RDB::rdb::Table := temp.resolveone(RDB::rdb::Table);		
		var propSet: OrderedSet(APP::reduced::Property);	
		
		//tento while cyklus by mel zajistit, ze netransientni property transientnich predku mezi aktualni mapovanou tridou a 
		//tridou predka, ktera se namapovala na tabulku, se namapuji take na sloupce, mozna je nadbytecny
		temp := self;
		while(temp <> null and (temp.isTransient = true or temp = self)){
				temp->properties->forEach(prop | prop.isTransient = false){
					propSet+=prop;
//					log(prop.name);
				};
				temp := temp.parent;
		};
				
		
		propSet->xmap toColumns(rootTable);	
		
		//u diskriminacniho sloupce neni doresen typ
		if(rootTable.containsDiscriminator() = false)then{
				rootTable.ownedColumns+=object RDB::rdb::TableColumn{
				name := "discriminator";
				type := "String";
			}
		}endif;
} 


//Namapuje tridu bez serializovatelneho potomka na tabulku
mapping APP::reduced::Class::toSerializableRootTable() : RDB::rdb::Table 
when {self.isGeneralClassSerializable()= true and self.hasSerializableAncestor() = false}
{
	log("toSerializableRootTable sekce " + self.name);
	name := self.name;
	
	var temp : APP::reduced::Class := self;
	var propSet: OrderedSet(APP::reduced::Property);
	
	while(temp <> null ){
		temp->properties->forEach(prop){
			propSet += prop;
		};
		temp := temp.parent;
	};
	
	propSet->xmap toColumns(result);
	
}

//mapovani toPK()
mapping RDB::rdb::TableColumn::toPK():RDB::rdb::PrimaryKey{
	init{
		object result : RDB::rdb::PrimaryKey{
			underlyingIndex := object RDB::rdb::Index{
			}
		};	
	}
	population{
				result.underlyingIndex.columns += self;
		}
}


mapping OrderedSet(APP::reduced::Property)::toColumns(inout table: RDB::rdb::Table){
	log("toColumns sekce");
	self->forEach(prop | prop.isTransient = false){
						var tableColumn:RDB::rdb::TableColumn; 
						if(prop.resolveone(RDB::rdb::TableColumn) = null)then{
							tableColumn:= prop.xmap toColumn(); 
							}else{
							var help :RDB::rdb::TableColumn = prop.resolveone(RDB::rdb::TableColumn);
							tableColumn := help.deepclone().oclAsType(RDB::rdb::TableColumn);
							//[RDB::rdb::TableColumn]->any(oclIsKindOf(RDB::rdb::TableColumn));
						}endif;
						
						tableColumn._owningTable = table;
						table.ownedColumns += tableColumn;
							if(prop.isID = true)then{		
								table.primaryKey := tableColumn.xmap toPK();
							}endif;
						
					};	
			table.constraints+=table.primaryKey;
}

query APP::reduced::Property::isSerializable() : Boolean {
	if(self.isTransient)then {
		return false;
	}endif;
	
	return true;
}

mapping APP::reduced::Property::toColumn( ) : RDB::rdb::TableColumn 
disjuncts APP::reduced::Property::toPrimitive
{

}

// namapuje Property, ktera ma jako typ jednu z Primitivnich trid, na Tablecolumn s 
//jmenem daneho primitivniho typu
mapping APP::reduced::Property::toPrimitive( ) : RDB::rdb::TableColumn
when {	self.isPrimitive() = true}
{
		log("toPrimitive property sekce "  + self.name);
		name:= self.name;
		type:= self.type.name;
}
	
// query na obecnou podminku nutnou k serializovatelnosti, uvazuje jen jednosloupcovy ID
query APP::reduced::Class::isGeneralClassSerializable():Boolean{
	//log("generalClassSerializationQuerry");
	if(self.isPrimitive = true or self.isTransient = true or self.hasOneIDProperty() = false) then {
		return false;
	}endif;
	
	return true;
}

//validace existence prave jedne Property PK v stromu dedicnosti, 
//v budoucich verzich nebude nutna jeji splnitelnost
query APP::reduced::Class::hasOneIDProperty():Boolean{
	var temp : APP::reduced::Class = self;
	var count : Integer = 0;

//	log("hasOneID");	
	while(temp <> null){	
		temp.properties->forEach( prop){
			if(prop.isID() and prop.isSerializable()) then {
				count := count + 1;
			}endif;
		};
		temp := temp.parent;
	};
	
	if(count = 1) then {
		return true;
	}endif;
	
	
	return false;
}

query APP::reduced::Property::isID():Boolean{
	if(self.isID = true) then {
		return true;
	}endif;
	
	return false;
}

// zjisti, jestli je dana Property primitivni prolezenim vsech primitivnich trid a porovnanim jmena
query APP::reduced::Property::isPrimitive():Boolean{
	self.owningClass.owningModel.classes->forEach(cl | cl.isPrimitive = true){
		if(cl.name = self.type.name) then {
			return true;
		} endif;
	};
	
	return false;
}

//zjisti, jestli ma dana trida serializovatelneho predka, v analyze je potrebna oprava
query APP::reduced::Class::hasSerializableAncestor():Boolean{
	var temp:APP::reduced::Class = self;
	
	//log("ser_Ancestor" + self.name);
	while(temp.parent <> null ){
	//	log(temp.name);
		temp := temp.parent;
		if(temp.isTransient = false ) then {
			return true;
		}endif;
	};
	 
	return false;
}

//zjisti, jestli ma nejaky predek zadany InheritanceType
query APP::reduced::Class::hasImplicitInheritanceType():Boolean{
	return self.hasChosenInheritanceType(APP::reduced::InheritanceType::__not_defined);	
} 

query APP::reduced::Class::hasSingleTableInheritanceType():Boolean{
	return self.hasChosenInheritanceType(APP::reduced::InheritanceType::singleTable);	
}

query APP::reduced::Class::hasTablePerClassInheritanceType():Boolean{
	return self.hasChosenInheritanceType(APP::reduced::InheritanceType::tablePerClass);	
}

query APP::reduced::Class::hasJoinedInheritanceType():Boolean{
	return self.hasChosenInheritanceType(APP::reduced::InheritanceType::joined);	
}


query APP::reduced::Class::hasChosenInheritanceType( chosenType:APP::reduced::InheritanceType):Boolean{
	var temp:APP::reduced::Class = self;
	
	while(temp.parent <> null ){
		if(temp.parent.inheritanceType <> null and temp.parent.inheritanceType <> chosenType ) then {
			return false;
		}endif;
		temp := temp.parent;
	};
	return true;

}

//zatim nepouzite
query APP::reduced::Class::getClassDepth():Integer{
	var depth : Integer = 0;
	var temp := self;
	
	while(temp.parent <> null){
		temp := temp.parent;
		depth := depth + 1;
	};
	
	return depth;
}

//vrati serializovatelnou root Class
query APP::reduced::Class::getSerializableRoot():APP::reduced::Class{
	var list : OrderedSet(APP::reduced::Class) := self.getPathToRoot();
	var index : Integer := list->size();
	var temp : APP::reduced::Class;
	
	while(index >= 1){
		temp := list->at(index);
		log(list->at(index).name);
		if(temp.isTransient = false)then{
			break;
		}endif;
		index := index - 1;
	};
	
	return temp;	
}

//vrati "cestu" od tridy az k Root tride, v poradi prvni trida na ktere je query volane, posledni root trida
query APP::reduced::Class::getPathToRoot():OrderedSet(APP::reduced::Class){
	var temp : APP::reduced::Class := self;
	var list : OrderedSet(APP::reduced::Class);
	
	while( temp <> null ){
		list += temp;
		temp := temp.parent;	
	};
	
	return list;
}

query RDB::rdb::Table::containsDiscriminator():Boolean{
	self.ownedColumns->forEach(col){
		if(col.name = "discriminator")then {
			return true;
		}endif;
	};
	return false;
}

query APP::reduced::Class::hasIdProperty():Boolean{
	self.properties->forEach(prop){
		if(prop.isID = true)then{
			return true;
		}endif;
	};
	return false;
}

//toto mapovani ted neni naimplementovano spravne, implementace slouzi jen k otestovani operace AddClass
mapping APP::reduced::ModelRoot::toOperated() : APP::reduced::ModelRoot{

	self.modelGenerations->forEach(generation){
		var newGeneration : APP::reduced::ModelGeneration :=object APP::reduced::ModelGeneration{
				classes := generation.classes.deepclone()[APP::reduced::Class];
				log("Generation");
			};
				
		self.operations->select(oclIsTypeOf(APP::reduced::operations::AddClass))
			[APP::reduced::operations::AddClass]->forEach(operation){
			
			log("--------------------"+operation.name+"-----------------------------------");
			newGeneration.classes += operation.xmap AddClass(newGeneration);
		};							
		result.modelGenerations+= newGeneration;
	}
}

// najde tridu dle jejiho jmena
query APP::reduced::ModelGeneration::findClass(cName : String) : APP::reduced::Class
{
	self.classes->forOne(c | c.name = cName ) {
		return c;
	};
	return null; // nekonzistentni [pozdeji nelze volat na null objektu]
}

// overi, jestli v dane generaci existuje trida s danym jmenem
query APP::reduced::ModelGeneration::isClassInGeneration(cName : String) : Boolean {
	self.classes->forOne(c | c.name = cName ) {
		return true;
	};
	return false;
}

// najde property dle jejiho jmena
query APP::reduced::Class::findProperty(pName : String) : APP::reduced::Property
{
	self.properties->forOne(p | p.name = pName ) {
		return p;
	};
	return null; // nekonzistentni [pozdeji nelze volat na null objektu]
}

// overi, jestli v dane tride existuje property s danym jmenem
query APP::reduced::Class::isPropertyInClass(pName : String) : Boolean {
	self.properties->forOne(p | p.name = pName ) {
		return true;
	};
	return false;
}

// operace namapuje tridu do dane generace, pokud trida v generaci neexistuje
mapping APP::reduced::operations::AddClass::
AddClass(inout g : APP::reduced::ModelGeneration) : APP::reduced::Class
when { g.isClassInGeneration(self.name) = false; }
{
	log("AddClass " + self.name);
	result.name := self.name;
	result.inheritanceType := APP::reduced::InheritanceType::__not_defined;
	result.parent := null;
	result.isAbstract := false;
	result.isEmbedded := false;
	result.isPrimitive := false;
	result.isTransient := false;
	
	// ID problem
	// PrimitiveClass -> defaultValue
	
	g.classes += result;
}

// oeprace namapuje property do dane tridy, pokud property ve tride neexistuje
mapping APP::reduced::operations::AddProperty::
AddProperty(inout g : APP::reduced::ModelGeneration) : APP::reduced::Property
when {
	g.isClassInGeneration(self.owningClassName) = true and 
	g.findClass(self.owningClassName).isPropertyInClass(self.name) = true;
}
{
	var c : APP::reduced::Class := g.findClass(self.owningClassName);
	
	log("AddProperty " + self.name);
	result.name := self.name;	
	result.type := g.findClass(self.type); // null
	result.lowerBound := self.lowerBound;
	result.upperBound := self.upperBound;
	
	// defaultValue
	
	c.properties += result;
}

// operace vytvori oboustranne navigabilni asociaci mezi tridami
mapping APP::reduced::operations::AddAssociation::
AddAssociation(inout g : APP::reduced::ModelGeneration) : APP::reduced::Class
when {
	g.isClassInGeneration(self.firstClassName) = true and
	g.findClass(self.firstClassName).isPropertyInClass(self.firstPropertyName) = true and
	g.isClassInGeneration(self.secondClassName) = true and
	g.findClass(self.secondClassName).isPropertyInClass(self.secondPropertyName) = true;
}
{
	log("AddAssociation between " + self.firstClassName + " and " + self.secondClassName);
	// namapování AddProperty() - self.firstClassName
	// namapování AddProperty() - self.secondClassName
}

// operace, ktera nastavi vlastnost isAbstract
mapping APP::reduced::operations::SetAbstract::
SetAbstract(inout g : APP::reduced::ModelGeneration) : APP::reduced::Class
when{ 
	g.isClassInGeneration(self.name) = true;
}
{
	var c : APP::reduced::Class := g.findClass(self.name);

	log("SetAbstract " + self.name);
	result.isAbstract = self.isAbstract;

    g.classes += result; // pridani nove tridy do generace
}

// operace, ktera nastavi vlastsnost isEmbedded
mapping APP::reduced::operations::SetEmbedded::
SetEmbedded(inout g : APP::reduced::ModelGeneration) : APP::reduced::Class
when{ 
	g.isClassInGeneration(self.name) = true;
}
{
	var c : APP::reduced::Class := g.findClass(self.name);

	log("SetEmbedded " + self.name);
	result.isEmbedded = self.isEmbedded;

    g.classes += result; // pridani nove tridy do generace
}

// operace, ktera nastavi vlastsnost parent
mapping APP::reduced::operations::SetParent::
SetParent(inout g : APP::reduced::ModelGeneration) : APP::reduced::Class
when{ 
	g.isClassInGeneration(self.name) = true;
}
{
	var c : APP::reduced::Class := g.findClass(self.name);

	log("SetParent " + self.name);
	result.parent = self.parentName;
	
	// ID problem

    g.classes += result; // pridani nove tridy do generace
}

// operace, ktera nastavi vlastsnost isPrimitive
mapping APP::reduced::operations::SetPrimitive::
SetPrimitive(inout g : APP::reduced::ModelGeneration) : APP::reduced::Class
when{ 
	g.isClassInGeneration(self.name) = true;
}
{
	var c : APP::reduced::Class := g.findClass(self.name);

	log("SetPrimitive " + self.name);
	result.isPrimitive = self.isPrimitive;

    g.classes += result; // pridani nove tridy do generace
}

// operace, ktera nastavi vlastsnost isID
mapping APP::reduced::operations::SetID::
SetID(inout g : APP::reduced::ModelGeneration) : APP::reduced::Property
when {
	g.isClassInGeneration(self.owningClassName) = true and 
	g.findClass(self.owningClassName).isPropertyInClass(self.name) = true;
}
{
	var c : APP::reduced::Class := g.findClass(self.owningClassName);
	var p : APP::reduced::Property := c.findProperty(self.name);

	log("SetID " + self.name);
	result.isID = self.isID;

    c.properties += result; // pridani nove property do tridy
}

// operace, ktera nastavi vlastsnost isOrdered
mapping APP::reduced::operations::SetOrdered::
SetID(inout g : APP::reduced::ModelGeneration) : APP::reduced::Property
when {
	g.isClassInGeneration(self.owningClassName) = true and 
	g.findClass(self.owningClassName).isPropertyInClass(self.name) = true;
}
{
	var c : APP::reduced::Class := g.findClass(self.owningClassName);
	var p : APP::reduced::Property := c.findProperty(self.name);

	log("SetOrdered " + self.name);
	result.isOrdered = self.isOrdered;

    c.properties += result; // pridani nove property do tridy
}

// operace, ktera nastavi vlastsnost isUnique
mapping APP::reduced::operations::SetUnique::
SetID(inout g : APP::reduced::ModelGeneration) : APP::reduced::Property
when {
	g.isClassInGeneration(self.owningClassName) = true and 
	g.findClass(self.owningClassName).isPropertyInClass(self.name) = true;
}
{
	var c : APP::reduced::Class := g.findClass(self.owningClassName);
	var p : APP::reduced::Property := c.findProperty(self.name);

	log("SetUnique " + self.name);
	result.isUnique = self.isUnique;

    c.properties += result; // pridani nove property do tridy
}